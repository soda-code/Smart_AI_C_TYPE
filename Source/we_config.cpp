#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <cmath>
#include <vector>
#include <AI_main.h> // For memcpy

// ------------------------------------------------------------------
// 假设的 C/C++ 结构体和常量定义 (与之前 C 实现保持一致)
// ------------------------------------------------------------------

// 网络层数

// 层的尺寸：输入(2), 隐藏(8)*8, 输出(1)


// Layer 结构体 (使用 std::vector 替代裸指针，更符合 C++ 实践)
struct Layer {
    // 假设这些是训练好的参数
    std::vector<float> weights;
    std::vector<float> biases;

    int input_size;
    int output_size;
};

// 假设全局变量 (需要在使用前填充真实数据)
// 只有 NUM_LAYERS - 1 层包含参数
std::vector<Layer> network_w(NUM_LAYERS - 1);

// ------------------------------------------------------------------
// 核心函数：保存权重到 C 文件
// ------------------------------------------------------------------

/**
 * @brief 将训练好的神经网络参数保存到一个 C 语言源文件中。
 * * @param filename 要创建的 C 文件名 (例如: "model_data.c")
 */
void save_weights_to_c_file_cpp(const std::string& filename) 
{
    // 使用 std::ofstream 打开文件
    std::ofstream ofs(filename, std::ios::out | std::ios::trunc);

    if (!ofs.is_open()) {
        std::cerr << "Error: Could not open file " << filename << " for writing." << std::endl;
        return;
    }

    // 写入文件头信息
    ofs << "/**\n"
        << " * GENERATED FILE: Neural Network Weights and Biases (10 Layers)\n"
        << " * Generated by C++ code.\n"
        << " * DO NOT EDIT MANUALLY\n"
        << " */\n\n"
        << "#include <stddef.h>\n\n";

    // 写入网络结构信息MODEL_NUM_LAYERSs
    ofs << "#define MODEL_NUM_LAYERS " << NUM_LAYERS << ";\n";
    ofs << "const int MODEL_LAYER_SIZES[" << NUM_LAYERS << "] = {";
    for (int i = 0; i < NUM_LAYERS; ++i) {
        ofs << LAYER_SIZES[i] << (i < NUM_LAYERS - 1 ? ", " : "");
    }
    ofs << "};\n\n";

    // 设置浮点数输出格式：科学计数法，高精度，并确保 C 语言兼容性
    ofs << std::scientific << std::setprecision(8);

    // --- 遍历并写入每一层的权重和偏置 ---
    for (size_t i = 0; i < network_w.size(); ++i) {
        const Layer& layer = network_w[i];

        // 1. 写入权重 (Weights)
        const auto& weights = layer.weights;
        ofs << "const float W_" << i << "[" << weights.size() << "] = {\n";

        for (size_t j = 0; j < weights.size(); ++j) {
            // 使用 .8eF 格式，确保 C 语言 float 类型后缀 'F'
            ofs << weights[j] << "F," << ((j + 1) % 5 == 0 && j != weights.size() - 1 ? "\n" : " ");
        }
        ofs << "\n};\n\n";

        // 2. 写入偏置 (Biases)
        const auto& biases = layer.biases;
        ofs << "const float B_" << i << "[" << biases.size() << "] = {\n";

        for (size_t j = 0; j < biases.size(); ++j) {
            ofs << biases[j] << "F," << ((j + 1) % 8 == 0 && j != biases.size() - 1 ? "\n" : " ");
        }
        ofs << "\n};\n\n";
    }

    ofs.close();
    std::cout << "Successfully saved network weights and biases to: " << filename << std::endl;
}
void setup_dummy_network(void)
{
    // 确保 network 向量有正确的尺寸 (9 层参数)
    network_w.resize(NUM_LAYERS - 1);

    for (size_t i = 0; i < network_w.size(); ++i) {
        network_w[i].input_size = LAYER_SIZES[i];
        network_w[i].output_size = LAYER_SIZES[i + 1];

        int w_count = network_w[i].input_size * network_w[i].output_size;
        int b_count = network_w[i].output_size;

        // 填充假数据 (模拟训练后的权重)
        for (int k = 0; k < w_count; ++k) {
            // 生成一些随机但可预测的浮点数
            network_w[i].weights.push_back(sin((float)(i * k) * 0.1f) * 0.5f);
        }

        for (int k = 0; k < b_count; ++k) {
            network_w[i].biases.push_back(cos((float)(i + k) * 0.15f) * 0.01f);
        }
    }
}

